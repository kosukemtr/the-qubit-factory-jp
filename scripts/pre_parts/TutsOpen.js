function TutsOpen() {
  if (0 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック1: ビット、ワイヤー、出力"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ビット（オレンジのディスク）は$$b:青色 $$b:ワイヤー 上を移動します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " キュービット（緑のディスク）は$$r:赤色 $$r:ワイヤー 上を移動します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 一度に1つのビットまたはキュービットしかタイルを占有できません。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 多くのレベルでは、望まれる出力に一致するビットまたはキュービットの流れを出力することが目標です。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 通常、望ましい出力を得る方法について指示が与えられます。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 84, 2, 2, 5, 24, 22, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 4, 2, 2, 11, 13, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 90, 24, 22, 33, 26, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 77, 23, 25, 1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 21, 3, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 54, 89, 26, -1, -1, 24, 25, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, 21, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 116, 21, 53, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, 50, 56, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 24, 22, 22, 22, 22, 91, 21, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, 21, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, 22, 22, 52, 52, 22, 26, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      var e = [
          [5, 1, 0, -1, "halt", 0, 0, !1],
          [5, 10, 1, -1, "freeze", 0, 0, !0],
          [0, 10, 3, -1, "halt", 0, 0, !1],
          [4, 3, 0, -1, "halt", 1, 0, !1],
          [5, 9, 1, 3, "halt", 0, 0, !0],
          [0, 12, 2, -1, "halt", 0, 0, !1],
          [5, 8, 1, 3, "halt", 0, 0, !0],
          [2, 12, 2, -1, "halt", 0, 0, !1],
          [1, 3, 3, -1, "halt", 0, 0, !1],
          [5, 7, 1, 3, "halt", 1, 0, !0],
          [3, 12, 2, -1, "flip", 0, 0, !1],
          [2, 5, 3, -1, "halt", 1, 0, !1],
          [5, 6, 2, -1, "halt", 0, 0, !0],
          [4, 12, 2, -1, "flip", 0, 0, !1],
          [6, 7, 3, -1, "halt", 1, 0, !0],
          [6, 12, 1, -1, "halt", 1, 0, !1],
          [1, 6, 0, -1, "wait", 1, 0, !1],
          [6, 8, 3, -1, "nullflip", 1, 0, !0],
          [6, 10, 1, -1, "halt", 1, 0, !1],
          [0, 6, 0, -1, "move", 0, 0, !1],
          [7, 9, 2, -1, "move", 1, 0, !1],
        ],
        t = 0;
      t < e.length;
      t++
    ) {
      var i = e[t].pop(),
        a = new Bit(...e[t]);
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    var r = [
      [3, 5, 2, -1, "halt", 0, !1],
      [5, 4, 1, -1, "halt", 1.1780972450961724, !1],
      [4, 2, 0, -1, "halt", 2.356194490192345, !1],
      [1, 2, 0, -1, "halt", 0, !1],
      [0, 3, 3, -1, "wait", -2.356194490192345, !1],
      [0, 4, 3, -1, "move", -2.748893571891069, !1],
    ];
    for (t = 0; t < r.length; t++) {
      i = r[t].pop();
      var s = new Qubit(...r[t]);
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    var o = [
      [0, 4, "qCreate", "free", 3, 2, 0, 0, -1],
      [0, 6, "cCreate", "free", 0, 2, 0, 0, -1],
      [1, 6, "delay", "transform", 0, 1, 0, 2, -1],
      [0, 3, "delay", "transform", 1, 1, 0, 2, -1],
      [6, 1, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
      [0, 1, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
      [6, 9, "cSplit", "free", 2, 0, 0, 0, -1],
      [7, 9, "cCreate", "free", 2, 2, 0, 0, -1],
      [5, 10, "compare", "free", 0, 0.7853981633974483, 0, 2, -1],
      [6, 8, "cInvert", "transform", 1, 0, 0, 2, -1],
      [3, 12, "cInvert", "transform", 0, 0, 0, 0, -1],
      [4, 12, "cInvert", "transform", 0, 0, 0, 0, -1],
    ];
    for (t = 0; t < o.length; t++) {
      var n = o[t].pop(),
        l = new Gate(...o[t]);
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (1 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック2: 回路の構築"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ワイヤーはメニューで選択後、$$d:左クリック $$d:+ $$d:ドラッグ して配置します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 同じ色のワイヤーは、ゲートや既存のワイヤー上で$$d:ドラッグクリック することでも作成できます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ゲートやワイヤーを削除するには$$d:右クリック $$d:+ $$d:ドラッグ するか、$$d:eraser $$d:tool を使います。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ゲートの向きは配置前に$$d:マウススクロール または $$d:矢印 $$d:keys  を使って調整できます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ゲートの設定は、配置後にゲートを選択して $$d:(左$$d:クリック) で調整します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 既存のゲートを$$d:shift $$d:+ $$d:left-click し続けるとコピーできます。",
      ),
      (TUTORIAL.type = "fixed"),
      (TUTORIAL.nFrames = 7),
      (TUTORIAL.timePerTick = 400),
      (TUTORIAL.i0High = -1),
      (TUTORIAL.j0High = -1),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 8, 60, 10, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 116, 75, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 116, 75, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 75,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      o = [
        [4, 3, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [4, 5, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [2, 7, "qCreate", "free", 2, 0, 0, 0, -1],
        [4, 7, "qCreate", "free", 1, 0, 0, 0, -1],
        [1, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [3, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [5, 9, "qCreate", "free", 1, 2, 0, 0, 1],
        [2, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [4, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [5, 11, "qCreate", "free", 3, 2, 0, 0, 1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    (TUTORIAL.grab = {
      type: "qCreate",
      i0: 3,
      j0: 9,
      k0: UBOARD[0].getGate(3, 9),
    }),
      (UBOARD[1] = UBOARD[0].copy()),
      (UBOARD[2] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[2]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 8, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 8, 60, 10, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 116, 75, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 116, 75, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 75,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      o = [
        [4, 3, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [4, 5, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [2, 7, "qCreate", "free", 2, 0, 0, 0, -1],
        [4, 7, "qCreate", "free", 1, 0, 0, 0, -1],
        [1, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [3, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [5, 9, "qCreate", "free", 1, 2, 0, 0, 1],
        [2, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [4, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [5, 11, "qCreate", "free", 3, 2, 0, 0, 1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[2].setGate(l);
    }
    (UBOARD[3] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[3]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 8, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 8, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 60, 10, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 116, 75, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 116, 75, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 75,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      o = [
        [4, 3, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [4, 5, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [2, 7, "qCreate", "free", 2, 0, 0, 0, -1],
        [4, 7, "qCreate", "free", 1, 0, 0, 0, -1],
        [1, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [3, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [5, 9, "qCreate", "free", 1, 2, 0, 0, 1],
        [2, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [4, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [5, 11, "qCreate", "free", 3, 2, 0, 0, 1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[3].setGate(l);
    }
    (UBOARD[4] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[4]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 8, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 8, 60, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 116, 75, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 116, 75, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 75,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      o = [
        [4, 3, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [2, 7, "qCreate", "free", 2, 0, 0, 0, -1],
        [4, 7, "qCreate", "free", 1, 0, 0, 0, -1],
        [1, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [3, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [5, 9, "qCreate", "free", 1, 2, 0, 0, 1],
        [2, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [4, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [5, 11, "qCreate", "free", 3, 2, 0, 0, 1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[4].setGate(l);
    }
    (UBOARD[5] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[5]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 8, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 8, 60, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 76, 116, 75, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 116, 75, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 116, 75, 75,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      o = [
        [4, 3, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [2, 7, "qCreate", "free", 2, 0, 0, 0, -1],
        [4, 7, "qCreate", "free", 1, 0, 0, 0, -1],
        [1, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [3, 9, "qCreate", "free", 1, 0, 0, 0, -1],
        [5, 9, "qCreate", "free", 1, 2, 0, 0, 1],
        [2, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [4, 11, "qCreate", "free", 3, 2, 0, 0, 1],
        [5, 11, "qCreate", "free", 3, 2, 0, 0, 1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[5].setGate(l);
    }
    UBOARD[6] = UBOARD[5].copy();
  } else if (2 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック3: ゲート"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ゲートは上を通過するビットやキュービットを変化させます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$b:青色 のゲートは（基本的に）ビットに作用します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$r:赤色 のゲートは（基本的に）キュービットに作用します。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$b:青または $$r:赤 のタブを持つゲートは同じ色のワイヤーに接続する必要があります。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$g:緑色 のタブを持つゲートはどちらの色のワイヤーにも接続できます。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 22, 52, 22, 52, 22, 89, 56, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 84, 2, 68, 2, 62, 2, 89, 76, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 75, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 90, -1, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 3, 2, 2, 60, 2, 2, 2, 84, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 4, 2, 2, 84, 22, 22, 89, 56, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      e = [
        [6, 2, 2, -1, "move", 0, 0, !1],
        [6, 10, 2, -1, "move", 0, 0, !1],
        [7, 2, 2, 0, "halt", 0, 0, !1],
        [7, 10, 2, 0, "halt", 1, 0, !1],
      ],
        t = 0;
      t < e.length;
      t++
    ) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (
      r = [
        [6, 4, 2, -1, "move", 0, !1],
        [0, 7, 1, -1, "move", 3.141592653589793, !1],
        [0, 11, 3, -1, "move", 3.141592653589793, !1],
        [7, 4, 2, 0, "halt", 0, !1],
        [0, 6, 1, 3, "halt", 0, !1],
        [0, 12, 3, 1, "halt", 3.141592653589793, !1],
      ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [0, 2, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 4, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 4, "delay", "reset", 0, 0, 0, 4, -1],
        [6, 2, "delay", "reset", 0, 0, 0, 4, -1],
        [7, 2, "cCreate", "free", 2, 0, 0, 0, -1],
        [7, 4, "qCreate", "free", 2, 0, 0, 0, -1],
        [4, 2, "cInvert", "free", 0, 0, 0, 0, -1],
        [2, 2, "cInvert", "free", 0, 0, 0, 1, -1],
        [2, 4, "qFlip", "free", 0, 0.7853981633974483, 0, 0, -1],
        [4, 4, "rotate", "free", 0, 4.319689898685965, 0, 0, -1],
        [3, 8, "measure", "free", 0, 0, 0, 0, -1],
        [3, 6, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [7, 8, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 10, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 7, "delay", "reset", 1, 0, 0, 4, -1],
        [0, 6, "qCreate", "free", 1, 1, 0, 0, -1],
        [0, 12, "qCreate", "free", 3, 1, 0, 0, -1],
        [0, 11, "delay", "reset", 1, 0, 0, 4, -1],
        [7, 10, "cCreate", "free", 2, 1, 0, 0, -1],
        [6, 10, "delay", "reset", 0, 0, 0, 4, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (3 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック4: 反転ゲートと再ゼロゲート"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$b:反転 $$b:ゲート はビットの状態を反転させます。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 反転ゲートはトグルで無作用（ビットを変更しない）にすることもできます。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$b:再ゼロ $$b:ゲート はビットを0状態に設定します。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 再ゼロゲートも無作用に切り替えることができます。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        24, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 23, 22, 22, 52, 22, 22, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 24, 22, 22, 52, 22, 22, 84, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 50, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 23, 22, 22, 52, 22, 22, 84, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, 22, 22, 52, 22, 22, 84, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, 56, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      e = [
        [0, 4, 3, -1, "halt", 0, 0, !1],
        [0, 2, 1, -1, "halt", 1, 0, !1],
        [0, 10, 3, -1, "halt", 0, 0, !1],
        [0, 8, 1, -1, "halt", 0, 0, !1],
        [0, 5, 3, -1, "wait", 1, 0, !1],
        [0, 1, 1, -1, "wait", 1, 0, !1],
        [0, 11, 3, -1, "wait", 0, 0, !1],
        [0, 7, 1, -1, "wait", 1, 0, !1],
        [0, 6, 2, 1, "move", 0, 0, !1],
        [0, 0, 2, -1, "halt", 1, 0, !1],
        [0, 12, 2, -1, "halt", 1, 0, !1],
        [0, 6, 2, 3, "move", 0, 1, !1],
      ],
        t = 0;
      t < e.length;
      t++
    ) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (r = [], t = 0; t < r.length; t++) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [3, 2, "cInvert", "free", 0, 0, 0, 0, -1],
        [0, 1, "delay", "transform", 1, 0, 0, 3, -1],
        [6, 2, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 4, "cInvert", "free", 0, 1, 0, 0, -1],
        [0, 5, "delay", "transform", 1, 0, 0, 3, -1],
        [6, 4, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 8, "cInvert", "free", 0, 0, 0, 1, -1],
        [6, 8, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 10, "cInvert", "free", 0, 1, 0, 1, -1],
        [6, 10, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 6, "cSplit", "free", 2, 0, 0, 0, -1],
        [1, 6, "cCreate", "create", 2, 1, 0, 0, -1],
        [0, 7, "delay", "transform", 1, 0, 0, 3, -1],
        [0, 11, "delay", "transform", 1, 0, 0, 3, -1],
        [1, 0, "cCreate", "create", 2, 1, 0, 0, -1],
        [1, 12, "cCreate", "create", 2, 1, 0, 0, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (4 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック5: コンバイナーとスプリッターゲート"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$b:コンバイナー は最大3本のワイヤーを1本の出力にまとめます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 複数のビット/キュービットが同じコンバイナーを待つ場合、出力方向から時計回りの順で優先されます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$b:ビット用 と$$r:キュービット用 にそれぞれ別のコンバイナーがあります。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$b:スプリッター は入力されたビットを複数の出力に複製します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " スプリッターの出力が対応するワイヤーやゲートに接続されている場合のみ複製ビットが生成されます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " スプリッターはキュービットには使用できません（量子論が禁じています！）",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        24, 89, 56, -1, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 23, 22, 22, 25, -1, 21, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 24, 22, 22, 44, 22, 26, 75, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 90, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 57, 4, 2, 66, 2, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 1, -1, 3, 2, 2, 5, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 55, 84, -1, -1, 74, 89, 6, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 90, -1, -1, 24, 22, 22, 84, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 23, 22, 22, 48, 22, 22, 84, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, 22, 22, 84, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 24, 22, 22, 48, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, 23, 22, 22, 84, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      e = [
        [0, 0, 2, -1, "halt", 1, 0, !1],
        [0, 2, 3, -1, "halt", 0, 0, !1],
        [0, 8, 1, -1, "halt", 0, 0, !1],
        [0, 10, 3, -1, "halt", 0, 0, !1],
        [1, 0, 2, -1, "wait", 1, 0, !1],
        [0, 3, 3, -1, "wait", 0, 0, !1],
        [0, 7, 1, -1, "wait", 0, 0, !1],
        [0, 11, 3, -1, "wait", 1, 0, !1],
      ],
        t = 0;
      t < e.length;
      t++
    ) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (
      r = [
        [6, 4, 1, -1, "halt", -1.9634954084936214, !1],
        [6, 6, 0, -1, "halt", -2.356194490192345, !1],
        [6, 3, 1, -1, "wait", 2.356194490192345, !1],
        [5, 6, 0, -1, "wait", -1.9634954084936214, !1],
      ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [3, 4, "qCombine", "free", 2, 0, 0, 0, -1],
        [3, 2, "cCombine", "free", 0, 0, 0, 0, -1],
        [5, 0, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [1, 6, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 3, "delay", "transform", 1, 0, 0, 3, -1],
        [6, 2, "qCreate", "create", 1, 2, 0, 0, -1],
        [5, 6, "delay", "transform", 0, 0, 0, 3, -1],
        [4, 6, "qCreate", "create", 0, 2, 0, 0, -1],
        [1, 0, "delay", "transform", 0, 0, 0, 3, -1],
        [2, 0, "cCreate", "create", 2, 2, 0, 0, -1],
        [0, 3, "delay", "transform", 1, 0, 0, 3, -1],
        [0, 4, "cCreate", "create", 3, 2, 0, 0, -1],
        [3, 8, "cSplit", "free", 0, 0, 0, 0, -1],
        [6, 7, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 8, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 9, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 7, "delay", "transform", 1, 0, 0, 3, -1],
        [0, 6, "cCreate", "create", 1, 2, 0, 0, -1],
        [3, 10, "cSplit", "free", 0, 0, 0, 0, -1],
        [6, 11, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 11, "delay", "transform", 1, 0, 0, 3, -1],
        [0, 12, "cCreate", "create", 3, 2, 0, 0, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (5 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック6: 生成と焼却"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 生成ゲートは新しい$$b:ビット や$$r:キュービット を作り出します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ゲートは$$d:固定、$$d:交互、$$d:ランダムの各状態で生成するよう設定できます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 生成回数を無制限にも有限にも設定できます。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$g:焼却炉 はビットやキュービットを消滅させます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 焼却炉は破壊した数を表示するよう切り替えられます。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 22, 56, -1, 74, 2, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 84, 22, 56, -1, 74, 2, 84, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 84, 22, 56, -1, 74, 2, 84, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 54, 89, 25, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, 75, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 26, -1, -1, 90, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 2, 6, -1, 4, 2, 6, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, 24, 84, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, 21, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23, 89, 56, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      e = [
        [3, 6, 0, -1, "halt", 1, 0, !1],
        [3, 12, 2, -1, "halt", 1, 0, !1],
        [2, 6, 0, -1, "wait", 1, 0, !1],
        [4, 12, 2, -1, "wait", 1, 0, !1],
        [1, 2, 2, -1, "halt", 0, 0, !1],
        [1, 3, 2, -1, "halt", 0, 0, !1],
        [1, 4, 2, -1, "halt", 1, 0, !1],
      ],
        t = 0;
      t < e.length;
      t++
    ) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (
      r = [
        [0, 9, 3, -1, "halt", 0, !1],
        [6, 9, 1, -1, "halt", 1.1780972450961724, !1],
        [0, 10, 3, -1, "wait", -2.356194490192345, !1],
        [6, 8, 1, -1, "wait", -0.39269908169872486, !1],
        [5, 2, 0, -1, "halt", 0, !1],
        [5, 3, 0, -1, "halt", 0, !1],
        [5, 4, 0, -1, "halt", 2.748893571891069, !1],
      ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [2, 2, "cCreate", "create", 2, 0, 0, 0, 6],
        [2, 3, "cCreate", "create", 2, 1, 0, 0, 8],
        [2, 4, "cCreate", "create", 2, 2, 0, 0, -1],
        [4, 2, "qCreate", "create", 0, 0, 0, 0, 6],
        [4, 3, "qCreate", "create", 0, 1, 0, 0, 8],
        [4, 4, "qCreate", "create", 0, 2, 0, 0, -1],
        [6, 4, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 3, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 2, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 2, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 3, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 4, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [1, 6, "cCreate", "create", 0, 2, 0, 0, -1],
        [2, 6, "delay", "transform", 0, 0, 0, 3, -1],
        [0, 11, "qCreate", "create", 3, 2, 0, 0, -1],
        [0, 10, "delay", "transform", 1, 0, 0, 3, -1],
        [5, 12, "cCreate", "create", 2, 2, 0, 0, -1],
        [4, 12, "delay", "transform", 0, 0, 0, 3, -1],
        [6, 8, "delay", "transform", 1, 0, 0, 3, -1],
        [6, 7, "qCreate", "create", 1, 2, 0, 0, -1],
        [2, 8, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [4, 10, "trash", "free", 0, 0.7853981633974483, 0, 1, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (6 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック7: （ビット）コントロールゲート"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$b:コントロール は投入されたビットに応じて、$$d:ターゲットリング 内に置かれたゲートの状態を能動的に変化させます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 建設中は黄色い$$d:スイッチアイコン で0プライムと1プライムの$$b:コントロール を切り替え、$$d:ターゲット $$d:ゲートを状態ごとに設定できます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 左の例では、$$b:`0` $$b:制御ビットを受け取るとターゲットゲートは左へ、$$b:`1` $$b:制御ビットを受け取ると上へビットを送ります。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ターゲットゲートが作動するたびにコントロールは未プライム状態に戻ります。再びビットやキュービットを受け入れるには、もう一度プライムする必要があります。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 40, -1, 40, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 52, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, 22, 22, 25, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 84, 22, 22, 25, -1, -1, 90, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 22, 22, 46, 22, 22, 26, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 22, 22, 42, 22, 22, 25, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        57, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      o = [
        [4, 1, "switch", "free", 0, 3, 0, 1, -1],
        [2, 4, "switch", "free", 0, 1, 0, 3, -1],
        [4, 4, "switch", "free", 0, 0, 0, 4, -1],
        [2, 5, "cInvert", "free", 0, 1, 0, 0, -1],
        [2, 5, "cInvert", "free", 0, 0, 1, 0, -1],
        [4, 5, "cInvert", "free", 0, 1, 0, 0, -1],
        [4, 5, "cInvert", "free", 0, 0, 1, 0, -1],
        [0, 9, "trash", "free", 0, 0.785398163397, 0, 0, -1],
        [0, 8, "trash", "free", 0, 0.785398163397, 0, 0, -1],
        [3, 10, "switch", "free", 2, 2, 0, 1, -1],
        [3, 9, "cCombine", "free", 2, 0, 0, 0, -1],
        [3, 9, "cCombine", "free", 3, 0, 1, 0, -1],
        [0, 10, "trash", "free", 0, 0.785398163397, 0, 0, -1],
        [6, 8, "delay", "transform", 1, 4, 0, 6, -1],
        [6, 12, "cCreate", "free", 3, 1, 0, 0, -1],
        [6, 11, "delay", "transform", 1, 1, 0, 6, -1],
        [3, 6, "cCreate", "free", 0, 2, 0, 0, -1],
      ],
        e = [
          [5, 10, 2, 0, "halt", 0, 0, !1],
          [6, 8, 1, -1, "wait", 0, 0, !1],
          [6, 11, 3, -1, "wait", 1, 0, !1],
          [6, 7, 1, 3, "halt", 1, 0, !1],
          [6, 6, 0, 3, "halt", 0, 0, !1],
          [5, 6, 0, 2, "halt", 1, 0, !1],
          [4, 6, 0, 2, "halt", 0, 0, !1],
          [6, 12, 3, 1, "move", 0, 0, !1],
        ],
        t = 0;
      t < e.length;
      t++
    ) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (t = 0; t < o.length; t++) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (7 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック8: 遅延ゲート、同期ゲート、BtQゲート"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$g:遅延$$g:ゲート はビットやキュービットを一定ティック数（0〜80ティック設定可能）その場に留めます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$g:同期$$g:ゲート は常にペアで配置され、両方が同時に占有されたときのみ通過を許可し、それ以外ではビットやキュービットを足止めします。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$g:ビットからキュービットへの(BtQ)ゲート は、入力ビットをキュービットへ変換します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 入力ビットが$$d:'0' 状態なら出力キュービットはゲート矢印と$$d:同方向 に、$$d:'1' 状態なら$$d:逆方向 になります。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 22, 22, 89, 22, 22, 89, 56, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 84, 2, 2, 80, 2, 2, 89, 89, 76, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 84, 22, 22, 82, 22, 22, 89, 56, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 24, 22, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 23, 22, 22, 85, 2, 2, 84, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 24, 22, 22, 85, 2, 2, 84, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      e = [
        [3, 2, 2, -1, "wait", 0, 0, !1],
        [4, 5, 2, -1, "halt", 1, 0, !1],
        [0, 10, 3, -1, "halt", 1, 0, !1],
        [0, 8, 1, -1, "halt", 0, 0, !1],
        [6, 2, 2, -1, "wait", 1, 0, !1],
        [6, 5, 2, -1, "wait", 0, 0, !1],
        [0, 11, 3, -1, "wait", 1, 0, !1],
        [0, 7, 1, -1, "wait", 0, 0, !1],
        [0, 12, 3, -1, "flip", 0, 0, !1],
        [0, 6, 2, -1, "halt", 0, 0, !1],
        [7, 2, 2, 0, "halt", 0, 0, !1],
        [1, 6, 2, -1, "halt", 0, 0, !1],
        [7, 5, 2, -1, "move", 1, 0, !1],
      ],
        t = 0;
      t < e.length;
      t++
    ) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (
      r = [
        [6, 4, 2, -1, "wait", 0.3926990816987241, !1],
        [7, 4, 2, 0, "halt", -1.9634954084936211, !1],
        [8, 4, 2, 0, "halt", 1.1780972450961724, !1],
      ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [6, 2, "delay", "transform", 0, 2, 0, 3, -1],
        [3, 2, "delay", "transform", 0, 0, 0, 2, -1],
        [7, 2, "cCreate", "free", 2, 2, 0, 0, -1],
        [0, 2, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 4, "sync", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 5, "sync", "free", 2, 0, 0, 0, -2],
        [0, 5, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 4, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 4, "delay", "transform", 0, 3, 0, 4, -1],
        [6, 5, "delay", "transform", 0, 1, 0, 4, -1],
        [7, 5, "cCreate", "free", 2, 2, 0, 0, -1],
        [8, 4, "qCreate", "free", 2, 2, 0, 0, -1],
        [7, 4, "delay", "free", 0, 0, 0, 2, -1],
        [3, 8, "upgrade", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 10, "upgrade", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 7, "delay", "transform", 1, 0, 0, 3, -1],
        [0, 11, "delay", "transform", 1, 0, 0, 3, -1],
        [0, 12, "cInvert", "transform", 1, 0, 0, 0, -1],
        [0, 13, "cCreate", "create", 3, 0, 0, 0, -1],
        [6, 8, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 10, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [2, 6, "cCreate", "create", 2, 0, 0, 0, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (8 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック9: キュービット入門"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " （非エンタングル状態の）$$r:キュービット は緑の円盤の縁を指す矢印で表されます。▲と▼の状態は `0` と `1` ビットに相当します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " キュービットは一般に任意の角度Θを取り得ますが、Qubit Factoryでは主にπ/8刻みの離散角度を使用します。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " キュービットの縁の色は波動関数の符号を表し、$$g:緑色 が正、$$p:紫色 が負です。符号は重ね合わせを扱うときに重要になります。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " キュービットを2π（360°）回転させると符号が反転します。奇妙に思えますが、これが正しい挙動です！",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 0, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 116, -1, 116, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, 0, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 84, 2, 62, 2, 62, 2, 89, 76, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      e = [],
        r = [
          [6, 10, 2, -1, "move", 0, !1],
          [7, 10, 2, 0, "halt", 0, !1],
          [2, 1, 2, 0, "halt", 0, !1],
          [4, 1, 2, 0, "halt", Math.PI, !1],
          [1, 4, 2, 0, "halt", (0 * Math.PI) / 8, !1],
          [2, 4, 2, 0, "halt", (1 * Math.PI) / 8, !1],
          [3, 4, 2, 0, "halt", (2 * Math.PI) / 8, !1],
          [4, 4, 2, 0, "halt", (3 * Math.PI) / 8, !1],
          [5, 4, 2, 0, "halt", (4 * Math.PI) / 8, !1],
          [1, 5, 2, 0, "halt", (5 * Math.PI) / 8, !1],
          [2, 5, 2, 0, "halt", (6 * Math.PI) / 8, !1],
          [3, 5, 2, 0, "halt", (7 * Math.PI) / 8, !1],
          [4, 5, 2, 0, "halt", (8 * Math.PI) / 8, !1],
          [5, 5, 2, 0, "halt", (9 * Math.PI) / 8, !1],
          [2, 8, 2, 0, "halt", (0 * Math.PI) / 8, !1],
          [4, 8, 2, 0, "halt", (0 * Math.PI) / 8, !1],
        ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i),
        15 === t &&
          ((s._ampsComp = [-1, 0]),
          (s._ampsRot = [-1, 0]),
          (s._ampsFinal = [-1, 0])),
        UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [7, 10, "qCreate", "free", 2, 0, 0, 0, -1],
        [0, 10, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 10, "delay", "reset", 0, 0, 0, 5, -1],
        [2, 10, "rotate", "free", 0, 3.141592653589793, 0, 0, -1],
        [4, 10, "rotate", "free", 0, 3.141592653589793, 0, 0, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (9 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック10: フリップゲートと回転ゲート"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$r:フリップ$$r:ゲート は選んだ軸でキュービットを反射させます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " フリップゲートはトグルで無作用（キュービットを変更しない）にできます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 出力の符号はキュービットがフリップ軸と同方向か逆方向かによって変わります。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$r:ローテーション$$r:ゲート はキュービットを半回転まで（-π〜πの範囲）回転させます。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 回転角が0の場合、ローテーションゲートは無作用となります。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 84, 2, 2, 68, 2, 2, 89, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 84, 2, 2, 68, 2, 2, 89, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 2, 2, 68, 2, 2, 87, 89, 56, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 2, 2, 68, 2, 2, 87, 89, 56, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 4, 89, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 3, 2, 2, 62, 2, 2, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 4, 2, 2, 62, 2, 2, 84, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 77, 4, 2, 62, 2, 2, 84, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 3, 89, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (
      e = [
        [6, 4, 2, -1, "upgrade", 0, 0, !1],
        [6, 5, 2, -1, "upgrade", 0, 0, !1],
        [7, 4, 2, -1, "wait", 1, 0, !1],
        [7, 5, 2, -1, "wait", 1, 0, !1],
      ],
        t = 0;
      t < e.length;
      t++
    ) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (
      r = [
        [5, 1, 2, -1, "halt", -1.178097245096172, !1],
        [5, 2, 2, -1, "halt", 0, !1],
        [0, 6, 2, -1, "halt", -1.9634954084936211, !1],
        [0, 9, 3, -1, "halt", -0.7853981633974484, !1],
        [1, 12, 2, -1, "halt", -2.748893571891069, !1],
        [6, 1, 2, -1, "wait", -1.5707963267948966, !1],
        [6, 2, 2, -1, "wait", -2.356194490192345, !1],
        [1, 6, 2, -1, "wait", 0, !1],
        [0, 10, 3, -1, "wait", -1.9634954084936211, !1],
        [2, 12, 2, -1, "wait", -1.178097245096172, !1],
      ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [3, 5, "qFlip", "free", 0, 1.5707963267948966, 0, 0, -1],
        [3, 4, "qFlip", "free", 0, 4.71238898038469, 0, 0, -1],
        [0, 4, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 5, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 5, "upgrade", "transform", 2, 0.7853981633974483, 0, 0, -1],
        [6, 4, "upgrade", "transform", 2, 0.7853981633974483, 0, 0, -1],
        [7, 4, "delay", "transform", 0, 0, 0, 3, -1],
        [7, 5, "delay", "transform", 0, 0, 0, 3, -1],
        [8, 4, "cCreate", "create", 2, 1, 0, 0, -1],
        [8, 5, "cCreate", "create", 2, 1, 0, 0, -1],
        [3, 1, "qFlip", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 2, "qFlip", "free", 0, 0.7853981633974483, 0, 1, -1],
        [7, 1, "qCreate", "create", 2, 2, 0, 0, -1],
        [7, 2, "qCreate", "create", 2, 2, 0, 0, -1],
        [0, 2, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 1, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 2, "delay", "transform", 0, 0, 0, 3, -1],
        [6, 1, "delay", "transform", 0, 0, 0, 3, -1],
        [3, 7, "rotate", "free", 0, 2.356194490192345, 0, 0, -1],
        [3, 9, "rotate", "free", 0, 4.71238898038469, 0, 0, -1],
        [1, 6, "delay", "transform", 0, 0, 0, 3, -1],
        [0, 10, "delay", "transform", 1, 0, 0, 3, -1],
        [2, 6, "qCreate", "create", 2, 2, 0, 0, -1],
        [0, 11, "qCreate", "create", 3, 2, 0, 0, -1],
        [6, 7, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 9, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 11, "rotate", "free", 0, 0, 0, 0, -1],
        [6, 11, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [2, 12, "delay", "transform", 0, 0, 0, 3, -1],
        [3, 12, "qCreate", "create", 2, 2, 0, 0, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (10 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック11: 測定"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$r:測定$$r:ゲート は、測定軸に沿うか反対向きのキュービットを出力します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 結果の確率は測定の向きとキュービットの向きの角度Θによって決まり、整列確率は cos²(Θ/2)、反整列確率は sin²(Θ/2) です。",
      ),
      TUTORIAL.info.push(" "),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 既に整列または反整列しているキュービットを測定しても状態は変わりません。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 測定結果に対応する古典ビット（整列なら `0`、反整列なら `1`）は、$$b:青タブ が互換ワイヤやゲートに接続されていれば出力されます。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (SCENARIO.text0 = { i0: 3, j0: 1.25, text: "prob: 0.85" }),
      (SCENARIO.text1 = { i0: 3, j0: 4.75, text: "prob: 0.15" }),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        4, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 90, -1, 0, 116, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 3, 2, 2, 60, 2, 2, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 0, 116, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 4, 2, 2, 60, 2, 2, 84, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, 90, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, 24, 22, 22, 84, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 4, 2, 2, 60, 2, 2, 84, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, 90, -1, -1, 23, 22, 22, 84, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, 77, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (e = [], t = 0; t < e.length; t++) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (
      r = [
        [0, 3, 1, -1, "halt", 0, !1],
        [2, 10, 0, -1, "halt", 0.7853981633974484, !1],
        [2, 7, 0, -1, "halt", 0, !1],
        [0, 2, 1, -1, "wait", 0, !1],
        [0, 11, 3, -1, "wait", -1.9634954084936211, !1],
        [0, 8, 3, -1, "wait", 3.141592653589793, !1],
        [0, 1, 1, -1, "halt", 0, !1],
        [0, 0, 2, -1, "halt", 0, !1],
        [0, 12, 3, 1, "halt", 1.1780972450961724, !1],
        [0, 9, 3, 1, "halt", 0, !1],
        [4, 2, 1, -1, "halt", Math.PI / 4, !1],
        [4, 4, 1, -1, "halt", (5 * Math.PI) / 4, !1],
        [2, 2, 1, -1, "halt", 0, !1],
        [2, 4, 1, -1, "halt", 0, !1],
      ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [6, 10, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 9, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [1, 0, "qCreate", "create", 2, 0, 0, 0, -1],
        [0, 12, "qCreate", "free", 3, 2, 0, 0, -1],
        [0, 11, "delay", "transform", 1, 2, 0, 3, -1],
        [3, 10, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 11, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 7, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 7, "measure", "free", 0, 0, 0, 0, -1],
        [0, 9, "qCreate", "free", 3, 1, 0, 0, -1],
        [0, 8, "delay", "transform", 1, 2, 0, 3, -1],
        [3, 3, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 3, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 2, "delay", "transform", 1, 0, 0, 3, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (11 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック12: キュービット制御ゲート"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$r:キュービット$$r:コントロールゲート は、制御キュービットの状態に応じて$$d:ターゲット$$d:リング内 の（フリップまたはローテート）ゲートの動作を変更します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
            " 制御キュービットとゲートが整列していればターゲットゲートは無作用となり、逆向きなら通常通り動作します。",
      ),
      TUTORIAL.info.push(""),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
            " ゲートは制御側とターゲット側のキュービットが同時に入るまで両方をその場に留めます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
            " 制御キュービットがゲートと整列も反整列もしていない場合、$$d:エンタングル$$d:状態 が生成されることがあります（キュービットの重ね合わせ/エンタングル状態参照）。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (SCENARIO.text0 = { i0: 3, j0: 2.5, text: " aligned" }),
      (SCENARIO.text1 = { i0: 3, j0: 3.5, text: "anti-aligned" }),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 84, 2, 68, 2, 62, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, 84, 2, 72, 2, 72, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 2, 70, 2, 70, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 2, 68, 2, 62, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 84, 2, 2, 70, 2, 2, 89, 76, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, 84, 2, 2, 68, 2, 2, 89, 76, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 84, 2, 2, 70, 2, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 84, 2, 2, 68, 2, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1,
      ]);
    for (e = [], t = 0; t < e.length; t++) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (
      r = [
        [0, 1, 2, -1, "delete", 0, !1],
        [0, 2, 2, -1, "delete", 0, !1],
        [0, 4, 2, -1, "delete", 3.141592653589793, !1],
        [0, 5, 2, -1, "delete", 0, !1],
        [3, 1, 2, -1, "halt", 0, !1],
        [3, 2, 2, -1, "halt", 0, !1],
        [3, 4, 2, -1, "halt", 3.141592653589793, !1],
        [3, 5, 2, -1, "halt", 3.141592653589793, !1],
        [6, 1, 2, -1, "move", 0, !1],
        [6, 2, 2, -1, "move", 0, !1],
        [6, 4, 2, -1, "move", 3.141592653589793, !1],
        [6, 5, 2, -1, "move", 0, !1],
        [7, 1, 2, 0, "halt", 0, !1],
        [7, 2, 2, 0, "halt", 0, !1],
        [7, 4, 2, 0, "halt", 3.141592653589793, !1],
        [7, 5, 2, 0, "halt", 0, !1],
        [3, 7, 2, -1, "wait", 0, !1],
        [6, 8, 2, -1, "move", 3.141592653589793, !1],
        [6, 10, 2, -1, "move", 1.5707963267948966, !1],
        [6, 11, 2, -1, "move", 0, !1],
        [6, 7, 2, -1, "move", 0, !1],
        [7, 8, 2, 0, "halt", 0, !1],
        [7, 10, 2, 0, "halt", 1.5707963267948966, !1],
        [7, 11, 2, 0, "halt", 0, !1],
        [8, 1, 2, 0, "halt", 0, !1],
        [8, 2, 2, 0, "halt", 0, !1],
        [8, 4, 2, 0, "halt", 0, !1],
        [8, 5, 2, 0, "halt", 0, !1],
        [8, 10, 2, 0, "halt", 0, !1],
        [8, 11, 2, 0, "halt", 0, !1],
        [7, 7, 2, 0, "halt", 0, !1],
      ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [2, 2, "qControl", "free", 2, 0, 0, 0, -1],
        [4, 2, "qControl", "free", 2, 0, 0, 0, -1],
        [2, 1, "qFlip", "free", 0, 1.5707963267948966, 0, 0, -1],
        [2, 1, "qFlip", "free", 0, 0.7853981633974483, 1, 0, -1],
        [4, 1, "rotate", "free", 0, 3.141592653589793, 0, 0, -1],
        [4, 1, "rotate", "free", 0, 0.7853981633974483, 1, 0, -1],
        [2, 4, "qControl", "free", 0, 0, 0, 0, -1],
        [4, 4, "qControl", "free", 0, 0, 0, 0, -1],
        [4, 5, "rotate", "free", 0, 3.141592653589793, 0, 0, -1],
        [4, 5, "rotate", "free", 0, 0.7853981633974483, 1, 0, -1],
        [2, 5, "qFlip", "free", 0, 1.5707963267948966, 0, 0, -1],
        [2, 5, "qFlip", "free", 0, 0.7853981633974483, 1, 0, -1],
        [0, 5, "trash", "transform", 0, 0.7853981633974483, 0, 0, -1],
        [0, 4, "trash", "transform", 0, 0.7853981633974483, 0, 0, -1],
        [0, 2, "trash", "transform", 0, 0.7853981633974483, 0, 0, -1],
        [0, 1, "trash", "transform", 0, 0.7853981633974483, 0, 0, -1],
        [6, 1, "delay", "reset", 0, 0, 0, 3, -1],
        [6, 2, "delay", "reset", 0, 0, 0, 3, -1],
        [6, 4, "delay", "reset", 0, 0, 0, 3, -1],
        [6, 5, "delay", "reset", 0, 0, 0, 3, -1],
        [8, 1, "qCreate", "free", 2, 0, 0, 0, -1],
        [8, 2, "qCreate", "free", 2, 0, 0, 0, -1],
        [8, 4, "qCreate", "free", 2, 0, 0, 0, -1],
        [8, 5, "qCreate", "free", 2, 0, 0, 0, -1],
        [7, 4, "qFlip", "free", 0, 1.5707963267948966, 0, 0, -1],
        [7, 2, "qFlip", "free", 0, 0.7853981633974483, 0, 1, -1],
        [7, 1, "qFlip", "free", 0, 0.7853981633974483, 0, 1, -1],
        [7, 5, "qFlip", "free", 0, 1.5707963267948966, 0, 1, -1],
        [3, 7, "qControl", "pretransform", 0, 0, 0, 0, -1],
        [6, 7, "delay", "reset", 0, 0, 0, 2, -1],
        [6, 8, "delay", "reset", 0, 0, 0, 5, -1],
        [7, 7, "qCreate", "free", 2, 1, 0, 0, -1],
        [7, 8, "qCreate", "free", 2, 1, 0, 0, -1],
        [0, 7, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 8, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 8, "qFlip", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 8, "qFlip", "free", 0, 1.5707963267948966, 1, 0, -1],
        [3, 10, "qControl", "free", 0, 0, 0, 0, -1],
        [8, 10, "qCreate", "free", 2, 0, 0, 0, -1],
        [6, 10, "delay", "reset", 0, 0, 0, 3, -1],
        [7, 10, "qFlip", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 10, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 11, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [3, 11, "qFlip", "free", 0, 1.5707963267948966, 0, 0, -1],
        [3, 11, "qFlip", "free", 0, 0.7853981633974483, 1, 0, -1],
        [8, 11, "qCreate", "free", 2, 0, 0, 0, -1],
        [7, 11, "qFlip", "free", 0, 1.5707963267948966, 0, 1, -1],
        [6, 11, "delay", "reset", 0, 0, 0, 3, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (12 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック13: キュービットの重ね合わせ"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ある軸に沿った単一の$$r:キュービット は、別の軸に沿ったキュービットの重み付き和（重ね合わせ）としても表せます。この軸の選択を$$d:基底 と呼びます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 例えるなら、単一の色が二つの色の混合で表せるのと同様です。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " ゲームでは重ね合わせはキュービットが状態を\`点滅\`することで表示されます。各成分の$$d:大きさ は境界の破線の長さで、$$d:符号 は色（緑=正、紫=負）で示されます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 状態の$$d:全体符号 は重要ではありませんが、成分間の$$d:相対符号 は重要です。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = new Array(FIELD.cols * FIELD.rows).fill(-1));
    for (e = [], t = 0; t < e.length; t++) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (o = [], t = 0; t < o.length; t++) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (13 === TUTORIAL.current) {
    (TUTORIAL.title = "ハンドブック14: エンタングル状態"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " $$d:エンタングル$$d:状態 は、非エンタングルなキュービットから$$r:量子$$r:制御ゲート を用いることでのみ生成できます。複数の量子制御ゲートを組み合わせれば、多数のキュービットのエンタングル状態を形成できます。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " エンタングルしているキュービットは半透明の雲で囲まれ、互いにエンタングルしているキュービットは同じ色の雲を共有します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 測定されたキュービットからはエンタングルが解除されますが、$$d:他の$$d:エンタングルされた キュービットも測定結果に応じて変化します（波動関数の崩壊参照）。そのため、エンタングル状態の測定では非エンタングルでは見られない$$d:相関 が現れます。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 2, 62, 2, 70, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 2, 70, 2, 68, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, 84, 2, 68, 2, 62, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 4, 2, 2, 2, 2, 2, 84, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 3, 2, 2, 70, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 4, 60, 2, 68, 2, 89, 68, 76, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, 3, 2, 2, 2, 2, 2, 84, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1,
      ]);
    for (e = [], t = 0; t < e.length; t++) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (
      r = [
        [6, 2, 2, -1, "move", 1.5707963267948966, !1],
        [6, 4, 2, -1, "move", 0, !1],
        [6, 3, 2, -1, "move", 0, !1],
        [6, 8, 2, -1, "move", 1.5707963267948966, !1],
        [6, 9, 2, -1, "move", 0, !1],
        [7, 2, 2, 0, "halt", 1.5707963267948966, !1],
        [7, 4, 2, 0, "halt", 0, !1],
        [7, 3, 2, 0, "halt", 0, !1],
        [7, 8, 2, 0, "halt", 1.5707963267948966, !1],
        [7, 9, 2, 0, "halt", 0, !1],
        [8, 2, 2, 0, "halt", 0, !1],
        [8, 4, 2, 0, "halt", 0, !1],
        [8, 3, 2, 0, "halt", 0, !1],
        [8, 8, 2, 0, "halt", 0, !1],
        [8, 9, 2, 0, "halt", 0, !1],
      ],
        t = 0;
      t < r.length;
      t++
    ) {
      (i = r[t].pop()), (s = new Qubit(...r[t]));
      (s.isGhost = i), UBOARD[0].setQubit(s);
    }
    for (
      o = [
        [0, 4, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [0, 2, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [8, 2, "qCreate", "free", 2, 0, 0, 0, -1],
        [8, 4, "qCreate", "free", 2, 0, 0, 0, -1],
        [6, 2, "delay", "reset", 0, 0, 0, 5, -1],
        [6, 4, "delay", "reset", 0, 0, 0, 5, -1],
        [8, 3, "qCreate", "free", 2, 0, 0, 0, -1],
        [0, 3, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 3, "delay", "reset", 0, 0, 0, 5, -1],
        [4, 2, "qControl", "free", 0, 0, 0, 0, -1],
        [2, 3, "qControl", "free", 0, 0, 0, 0, -1],
        [7, 2, "qFlip", "free", 0, 0.7853981633974483, 0, 0, -1],
        [4, 3, "qFlip", "free", 0, 1.5707963267948966, 0, 0, -1],
        [4, 3, "qFlip", "free", 0, 0.7853981633974483, 1, 0, -1],
        [2, 4, "qFlip", "free", 0, 1.5707963267948966, 0, 0, -1],
        [2, 4, "qFlip", "free", 0, 0.7853981633974483, 1, 0, -1],
        [4, 4, "rotate", "free", 0, 0.7853981633974483, 0, 0, -1],
        [2, 2, "rotate", "free", 0, 0.7853981633974483, 0, 0, -1],
        [7, 3, "qFlip", "free", 0, 0.7853981633974483, 0, 1, -1],
        [7, 4, "qFlip", "free", 0, 0.7853981633974483, 0, 1, -1],
        [4, 8, "qControl", "free", 0, 0, 0, 0, -1],
        [8, 8, "qCreate", "free", 2, 0, 0, 0, -1],
        [7, 8, "qFlip", "free", 0, 0.7853981633974483, 0, 0, -1],
        [6, 8, "delay", "reset", 0, 0, 0, 5, -1],
        [6, 9, "delay", "reset", 0, 0, 0, 5, -1],
        [7, 9, "qFlip", "free", 0, 0.7853981633974483, 0, 1, -1],
        [8, 9, "qCreate", "free", 2, 0, 0, 0, -1],
        [4, 9, "qFlip", "free", 0, 1.5707963267948966, 0, 0, -1],
        [4, 9, "qFlip", "free", 0, 0.7853981633974483, 1, 0, -1],
        [2, 9, "measure", "free", 0, 0.7853981633974483, 0, 0, -1],
        [7, 10, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
        [7, 7, "trash", "free", 0, 0.7853981633974483, 0, 0, -1],
      ],
        t = 0;
      t < o.length;
      t++
    ) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    var h = new Entangled(3);
    h.setQubits([
      new Qubit(2, 11, 0, 2, "halt", 0),
      new Qubit(3, 11, 0, 2, "halt", 0),
      new Qubit(4, 11, 0, 2, "halt", 0),
    ]),
      (h.ampsComp = [0.5, 0, 0, -0.5, 0, 0.5, 0, 0.5]),
      h.computeRotAmps(),
      h.computeAllEnts(),
      UBOARD[0].setEntGroup(h),
      (UBOARD[1] = UBOARD[0].copy().updateOneStep());
  } else if (14 === TUTORIAL.current) {
    SVG.tutorialB.activate(),
      (SVG.tutorialB.svg.style.zIndex = "31"),
      (TUTORIAL.title = "ハンドブック15: 状態アナライザー"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        "工場を一時停止中にキュービットをクリックすると表示される$$d:状態 $$d:アナライザー では、キュービットやエンタングル状態の詳細を確認できます:",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 各基底状態における振幅（それぞれのキュービット基底を変更する機能付き）。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 各キュービットの$$d:エンタングルエントロピー （0〜1で表されるエンタングル度合い）。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " 指定した基底で1つのキュービットを測定したときの$$d:期待結果 。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = new Array(FIELD.cols * FIELD.rows).fill(-1));
    for (e = [], t = 0; t < e.length; t++) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (o = [], t = 0; t < o.length; t++) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else if (15 === TUTORIAL.current) {
    SVG.tutorialB.activate(),
      (SVG.tutorialB.svg.style.zIndex = "31"),
      (TUTORIAL.title = "ハンドブック16: 波動関数の崩壊"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " エンタングル状態のキュービットを測定すると残りのキュービットは（最初のキュービットの測定結果に依存する）新しい状態へ収縮します。各キュービット下の$$d:オレンジ色のボタン をクリックして状態アナライザーを使えば、新しい状態を予測できます。",
      ),
      TUTORIAL.info.push("左の例では次の通りです:"),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " キュービット1が状態 " +
          String.fromCharCode(9650) +
          " に測定された場合、キュービット2は (" +
          String.fromCharCode(9654) +
          " + " +
          String.fromCharCode(9664) +
          ") の等分重ね合わせに収縮します。",
      ),
      TUTORIAL.info.push(
        String.fromCharCode(8226) +
          " キュービット1が状態 " +
          String.fromCharCode(9660) +
          " に測定された場合、キュービット2は (" +
          String.fromCharCode(9654) +
          " - " +
          String.fromCharCode(9664) +
          ") の奇数重ね合わせに収縮します。",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[0]._tiles = new Array(FIELD.cols * FIELD.rows).fill(-1));
    for (e = [], t = 0; t < e.length; t++) {
      (i = e[t].pop()), (a = new Bit(...e[t]));
      (a.isGhost = i), UBOARD[0].setBit(a);
    }
    for (o = [], t = 0; t < o.length; t++) {
      (n = o[t].pop()), (l = new Gate(...o[t]));
      (l.counterMax = n), UBOARD[0].setGate(l);
    }
    UBOARD[1] = UBOARD[0].copy().updateOneStep();
  } else
    16 === TUTORIAL.current &&
      ((TUTORIAL.title = "ハンドブック0: 操作リファレンス"),
      (TUTORIAL.info = []),
      TUTORIAL.info.push(
        "ゲーム操作（建設フェーズ中）:                   ---------------------------------------------------------------",
      ),
      TUTORIAL.info.push(" オブジェクトの選択・配置・操作: $$d:LMB. "),
      TUTORIAL.info.push(
        " オブジェクトの削除: $$d:RMB $$d:(または $$d:`E` $$d:キー後に $$d:LMB). ",
      ),
      TUTORIAL.info.push(
        " ゲートの回転（配置中）: $$d:マウススクロール $$d:(または $$d:◀/► $$d:キー). ",
      ),
      TUTORIAL.info.push(
        " 制御ゲートの状態切替: $$d:ダブルクリック $$d:(または $$d:ALT/OPT-クリック).",
      ),
      TUTORIAL.info.push(
        " ゲートをコピー: $$d:SHIFT+LMB $$d:(+ドラッグで広い範囲を選択). ",
      ),
      TUTORIAL.info.push(
        " ゲートを切り取り: $$d:CTRL/CMD+LMB $$d:(+ドラッグで広い範囲を選択). ",
      ),
      TUTORIAL.info.push(
        " 最後の操作を取り消す/やり直す: $$d:`Z` $$d:/ $$d:`X` $$d:キー. ",
      ),
      TUTORIAL.info.push(
        " メニューから前/次の利用可能なゲートを選択: $$d:`Q` $$d:/ $$d:`W` $$d:キー. ",
      ),
      TUTORIAL.info.push(
        " ゲートのショートカット（1〜3列）: $$d:[1-6], $$d:SHIFT+[1-6], $$d:CTRL+[1-6].",
      ),
      TUTORIAL.info.push(" 工場レイアウトをクリップボードにコピー: $$d:CTRL+C. "),
      TUTORIAL.info.push(
        " クリップボードから工場を貼り付け: $$d:CTRL+V $$d:(Firefoxは非対応). ",
      ),
      (TUTORIAL.type = "free"),
      (TUTORIAL.timePerTick = 800),
      (TUTORIAL.grab = 0),
      (TUTORIAL.basis = OPTS.basis),
      (OPTS.basis = "natural"),
      (SCENARIO.channelsCol = [0, 0, 0, 0, 0, 0]),
      (UBOARD[0] = new Board(CANV.tutorialGates.ctx, 19, 14)),
      (UBOARD[1] = UBOARD[0].copy().updateOneStep()));
}
